/*
TrueType to Adafruit_GFX font converter.  Derived from Peter Jakobs'
Adafruit_ftGFX fork & makefont tool, and Paul Kourany's Adafruit_mfGFX.

NOT AN ARDUINO SKETCH.  This is a command-line tool for preprocessing
fonts to be used with the Adafruit_GFX Arduino library.

For UNIX-like systems.  Outputs to stdout; redirect to header file, e.g.:
  ./fontconvert ~/Library/Fonts/FreeSans.ttf 18 > FreeSans18pt7b.h

REQUIRES FREETYPE LIBRARY.  www.freetype.org

Currently this only extracts the printable 7-bit ASCII chars of a font.
Will eventually extend with some int'l chars a la ftGFX, not there yet.
Keep 7-bit fonts around as an option in that case, more compact.

See notes at end for glyph nomenclature & other tidbits.
*/
#include "flatconvert.h"
#include "cxxopts.hpp"
/**
 * 
 * @param xfontFile
 * @param xsymbolName
 */
 FontConverter::FontConverter(const std::string &xfontFile, const std::string &xsymbolName,const std::string &xoutputFile)
 {
    fontFile=xfontFile;
    symbolName=xsymbolName;
    outputFile=xoutputFile;
    ftInited=false;    
    face_height=0;
    output=NULL;
 }
 FontConverter::~FontConverter()
 {
    if(ftInited)
        FT_Done_FreeType(library);
    if(output)
    {
        fclose(output);
        output=NULL;
    }
 }
 /**
  * 
  * @param c
  * @return 
  */
 char FontConverter::printable(int c)
 {
     if(c<' ') return '.';
     return (char )c;
 }
 
 
 /**
  * 
  * @return 
  */
bool    FontConverter::initFreeType(int size)
{
  int err;   
  // Init FreeType lib, load font
  if ((err = FT_Init_FreeType(&library))) 
  {
    fprintf(stderr, "FreeType init error: %d", err);
    return false;
  }
  
  // Use TrueType engine version 35, without subpixel rendering.
  // This improves clarity of fonts since this library does not
  // support rendering multiple levels of gray in a glyph.
  // See https://github.com/adafruit/Adafruit-GFX-Library/issues/103
  FT_UInt interpreter_version = TT_INTERPRETER_VERSION_35;
  FT_Property_Set(library, "truetype", "interpreter-version", &interpreter_version);
  // prepare names
  ftInited=true;
  if ((err = FT_New_Face(library, fontFile.c_str(), 0, &face))) 
  {
    fprintf(stderr, "Font load error: %d", err);
    FT_Done_FreeType(library);
    return err;
  }

  // << 6 because '26dot6' fixed-point format
  FT_Set_Char_Size(face, size << 6, 0, DPI, 0);
  return true;
}
/**
 * 
 * @param size
 * @return 
 */
bool    FontConverter::init(int size, int xfirst, int xlast)
{
    if(!initFreeType(size)) return false;
    if(xlast>xfirst)          
    {
      first=xfirst;
      last=xlast;
    }else
    {
       first=xlast;
       last=xfirst ; 
    }               
    output=fopen(outputFile.c_str(),"wb");
    if(!output)
    {
         fprintf(stderr, "cannot open %s file\n", outputFile.c_str());
         return false;
    }
    return true;
}
  
/**
 * 
 */  
void   FontConverter::printHeader()  
{
    fprintf(output,"// Generated by flatconvert  https://github.com/mean00/fontconvert.git \n");
    fprintf(output,"// a modified version of adafruit fontconvert \n");
    fprintf(output,"#pragma once\n");
}
  
  /**
   * 
   */
void   FontConverter::printIndex()
{
  fprintf(output,"const GFXglyph %sGlyphs[] PROGMEM = {\n", symbolName.c_str());
  for(int i = first;i <= last; i++) 
  {
    GFXglyph &glyph=listOfGlyphs[i-first];
    fprintf(output,"  { %5d, %3d, %3d, %3d, %4d, %4d }", glyph.bitmapOffset,
           glyph.width, glyph.height, glyph.xAdvance, glyph.xOffset,
           glyph.yOffset);
    fprintf(output,",   // 0x%02X '%c' \n", i,printable(i));
  }
   fprintf(output,"\n};\n");
}

bool FontConverter::saveBitmap(const char *bitmap)
{
  printf("Saving bitmap to %s\n",bitmap);
  FILE *f=fopen(bitmap,"wb");
  if(!f)
  {
      printf("Error\n");
      return false;
  }
  bitPusher.align();
  int sz=bitPusher.offset();
  fwrite(bitPusher.data(),sz,1,f);  
  fclose(f);
  return true;
}

/**
 * 
 */
void FontConverter::printBitmap()
{
    
  fprintf(output,"const uint8_t %sBitmaps[] PROGMEM = {\n ", symbolName.c_str());
  bitPusher.align();
  int sz=bitPusher.offset();
  const uint8_t *data=bitPusher.data();
  
  int tab=0;
  for(int i=0;i<sz;i++)
  {
      fprintf(output," 0x%02X,",data[i]);
      tab++;
      if(tab==12)
      {
          fprintf(output,"\n ");
          tab=0;
      }
  }

  fprintf(output," };\n\n"); // End bitmap array

}

/**
 * 
 */
void   FontConverter::printFooter()
{
  
  // Output font structure
  fprintf(output,"const GFXfont %s PROGMEM = {\n", symbolName.c_str());
  fprintf(output,"  (uint8_t  *)%sBitmaps,\n", symbolName.c_str());
  fprintf(output,"  (GFXglyph *)%sGlyphs,\n", symbolName.c_str());
  if(!face_height) 
  {  // No face height info, assume fixed width and get from a glyph.  
    fprintf(output,"  0x%02X, 0x%02X, %d };\n\n", first, last, listOfGlyphs[0].height);
  } 
  else 
  {
    fprintf(output,"  0x%02X, 0x%02X, %d };\n\n", first, last, face_height);
  }
    
  int sz=bitPusher.offset();
  fprintf(output,"// Bitmap : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
  sz=(last-first+1)*sizeof(GFXglyph);
  fprintf(output,"// Header : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
  sz+=bitPusher.offset()+sizeof(GFXfont);
  fprintf(output,"//--------------------------------------\n");
  fprintf(output,"// total : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
}
