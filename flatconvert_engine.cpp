/*
TrueType to Adafruit_GFX font converter.  Derived from Peter Jakobs'
Adafruit_ftGFX fork & makefont tool, and Paul Kourany's Adafruit_mfGFX.

NOT AN ARDUINO SKETCH.  This is a command-line tool for preprocessing
fonts to be used with the Adafruit_GFX Arduino library.

For UNIX-like systems.  Outputs to stdout; redirect to header file, e.g.:
  ./fontconvert ~/Library/Fonts/FreeSans.ttf 18 > FreeSans18pt7b.h

REQUIRES FREETYPE LIBRARY.  www.freetype.org

Currently this only extracts the printable 7-bit ASCII chars of a font.
Will eventually extend with some int'l chars a la ftGFX, not there yet.
Keep 7-bit fonts around as an option in that case, more compact.

See notes at end for glyph nomenclature & other tidbits.
*/
#include "flatconvert.h"


/**
 *
 * @param xfontFile
 * @param xsymbolName
 */
 FontConverter::FontConverter(const std::string &xfontFile, const std::string &xsymbolName,const std::string &xoutputFile)
 {
    fontFile=xfontFile;
    symbolName=xsymbolName;
    outputFile=xoutputFile;
    ftInited=false;
    face_height=0;
    output=NULL;
    compressed=false;
 }
 FontConverter::~FontConverter()
 {
    if(ftInited)
        FT_Done_FreeType(library);
    if(output)
    {
        fclose(output);
        output=NULL;
    }
 }
 /**
  *
  * @param c
  * @return
  */
 char FontConverter::printable(int c)
 {
     if(c<' ') return '.';
     return (char )c;
 }


 /**
  *
  * @return
  */
bool    FontConverter::initFreeType(int size)
{
  int err;
  // Init FreeType lib, load font
  if ((err = FT_Init_FreeType(&library)))
  {
    fprintf(stderr, "FreeType init error: %d", err);
    return false;
  }

  // Use TrueType engine version 35, without subpixel rendering.
  // This improves clarity of fonts since this library does not
  // support rendering multiple levels of gray in a glyph.
  // See https://github.com/adafruit/Adafruit-GFX-Library/issues/103
  FT_UInt interpreter_version = TT_INTERPRETER_VERSION_35;
  FT_Property_Set(library, "truetype", "interpreter-version", &interpreter_version);
  // prepare names
  ftInited=true;
  if ((err = FT_New_Face(library, fontFile.c_str(), 0, &face)))
  {
    fprintf(stderr, "Font load error: %d", err);
    FT_Done_FreeType(library);
    return err;
  }

  // << 6 because '26dot6' fixed-point format
  FT_Set_Char_Size(face, size << 6, 0, DPI, 0);
  return true;
}
/**
 *
 * @param size
 * @return
 */
bool    FontConverter::init(int size, int bpp,int xfirst, int xlast)
{
    this->bpp=bpp;
    if(!initFreeType(size)) return false;
    if(xlast>xfirst)
    {
      first=xfirst;
      last=xlast;
    }else
    {
       first=xlast;
       last=xfirst ;
    }
    output=fopen(outputFile.c_str(),"wb");
    if(!output)
    {
         fprintf(stderr, "cannot open %s file\n", outputFile.c_str());
         return false;
    }
    return true;
}

/**
 *
 */
void   FontConverter::printHeader()
{
    fprintf(output,"// Generated by flatconvert  https://github.com/mean00/fontconvert.git \n");
    fprintf(output,"// a modified version of adafruit fontconvert \n");
    fprintf(output,"#pragma once\n");
}

  /**
   *
   */
void   FontConverter::printIndex()
{
  fprintf(output,"const PFXglyph %sGlyphs[] PROGMEM = {\n", symbolName.c_str());
  for(int i = first;i <= last; i++)
  {
    PFXglyph &glyph=listOfGlyphs[i-first];
    fprintf(output,"  { %5d, %3d, %3d, %3d, %4d, %4d}",
           glyph.bitmapOffset,
           glyph.width,
           glyph.height,
           glyph.xAdvance,
           glyph.xOffset,
           (int)glyph.yOffset);
    fprintf(output,",   // 0x%02X '%c' \n", i,printable(i));
  }
   fprintf(output,"\n};\n");
}

bool FontConverter::saveBitmap(const char *bitmap)
{
  printf("Saving bitmap to %s\n",bitmap);
  FILE *f=fopen(bitmap,"wb");
  if(!f)
  {
      printf("Error\n");
      return false;
  }
  bitPusher.align();
  int sz=bitPusher.offset();
  fwrite(bitPusher.data(),sz,1,f);
  fclose(f);
  return true;
}

/**
 *
 */
void FontConverter::printBitmap()
{

  fprintf(output,"const uint8_t %sBitmaps[] PROGMEM = {\n ", symbolName.c_str());
  bitPusher.align();
  int sz=bitPusher.offset();
  const uint8_t *data=bitPusher.data();

  int tab=0;
  for(int i=0;i<sz;i++)
  {
      fprintf(output," 0x%02X,",data[i]);
      tab++;
      if(tab==12)
      {
          fprintf(output,"\n ");
          tab=0;
      }
  }

  fprintf(output," };\n\n"); // End bitmap array

}

/**
 *
 */
void   FontConverter::printFooter()
{

  // Output font structure
  fprintf(output,"const PFXfont %s PROGMEM = {\n", symbolName.c_str());
  fprintf(output,"  (uint8_t  *)%sBitmaps,\n", symbolName.c_str());
  fprintf(output,"  (PFXglyph *)%sGlyphs,\n", symbolName.c_str());
  if(!face_height)
  {  // No face height info, assume fixed width and get from a glyph.
    fprintf(output,"  0x%02X, 0x%02X, %d,\n" , first, last, listOfGlyphs[0].height);
  }
  else
  {
    fprintf(output,"  0x%02X, 0x%02X, %d, ", first, last, face_height);
  }
  fprintf(output,"\n  %1d,%1d}; // bit per pixel, compression \n\n",bpp,(int)compressed);
  int sz=bitPusher.offset();
  fprintf(output,"// Bitmap : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
  sz=(last-first+1)*sizeof(PFXglyph);
  fprintf(output,"// Header : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
  sz+=bitPusher.offset()+sizeof(PFXfont);
  fprintf(output,"//--------------------------------------\n");
  fprintf(output,"// total : about %d bytes (%d kBytes)\n",sz,(sz+1023)/1024);
}


bool  FontConverter::convert()
{
    switch(bpp)
    {
        case 1: return convert1bit();break;
        case 4:
        case 8:
        case 2: return convertNbit(bpp);break;
        default:
            printf("Unsupported bpp, only 1 or 4");
            break;
    }
    return false;
}
 /**
  *
  * @return
  */
 bool FontConverter::convertNbit(int n)
 {
     int err;
     FT_Glyph glyph;
     PFXglyph zeroGlyph= (PFXglyph){0,0,0,0,0,0};     
     for(int i=first;i<=last;i++)
     {

        // MONO renderer provides clean image with perfect crop
        // (no wasted pixels) via bitmap struct.
        bool renderingOk=true;
        if ((err = FT_Load_Char(face, i, FT_LOAD_TARGET_NORMAL))) {     fprintf(stderr, "Error %d loading char '%c'\n", err, i); renderingOk=false;   }
        if ((err = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL))) {      fprintf(stderr, "Error %d rendering char '%c'\n", err, i);     renderingOk=false;  }
        if ((err = FT_Get_Glyph(face->glyph, &glyph))) {      fprintf(stderr, "Error %d getting glyph '%c'\n", err, i);    renderingOk=false;    }

        if(!renderingOk)
        {
            listOfGlyphs.push_back(zeroGlyph);
            continue;
        }
        FT_Bitmap *bitmap = &face->glyph->bitmap;
        FT_BitmapGlyphRec *g= (FT_BitmapGlyphRec *)glyph;

        // Minimal font and per-glyph information is stored to
        // reduce flash space requirements.  Glyph bitmaps are
        // fully bit-packed; no per-scanline pad, though end of
        // each character may be padded to next byte boundary
        // when needed.  16-bit offset means 64K max for bitmaps,
        // code currently doesn't check for overflow.  (Doesn't
        // check that size & offsets are within bounds either for
        // that matter...please convert fonts responsibly.)
        bitPusher.align();
        int startOffset=bitPusher.offset();
        PFXglyph thisGlyph;
        thisGlyph.bitmapOffset = bitPusher.offset();
        thisGlyph.width = bitmap->width;
        thisGlyph.height = bitmap->rows;
        thisGlyph.xAdvance = face->glyph->advance.x >> 6;
        thisGlyph.xOffset = g->left;
        thisGlyph.yOffset = 1 - g->top;
        listOfGlyphs.push_back(thisGlyph);

        for (int y = 0; y < bitmap->rows; y++)
        {
          const uint8_t *line=bitmap->buffer+y * bitmap->pitch;
          for (int x = 0; x < bitmap->width; x++)
          {
            switch(n)
            {
                case 4: bitPusher.add4Bits(line[x]>>4);break;
                case 2: bitPusher.add2Bits(line[x]>>6);break;
                case 8: bitPusher.add8Bits(line[x]);break;
                default:
                    printf("Unsupported bpp\n");
                    exit(-1);
                    break;
            }
          }
        }
        if(compressed)
        {
            bitPusher.align();
            int size=bitPusher.offset()-startOffset;
            compressInPlace((uint8_t *)(bitPusher.data()+startOffset),size);
            bitPusher.setOffset(startOffset+size);
        }
    }
    face_height= face->size->metrics.height >> 6;
    FT_Done_Glyph(glyph);
    return true;
 }



 /**
  *
  * @return
  */
 bool FontConverter::convert1bit()
 {
     int err;
     FT_Glyph glyph;
     PFXglyph zeroGlyph= (PFXglyph){0,0,0,0,0,0};
     for(int i=first;i<=last;i++)
     {

        // MONO renderer provides clean image with perfect crop
        // (no wasted pixels) via bitmap struct.
        bool renderingOk=true;
        if ((err = FT_Load_Char(face, i, FT_LOAD_TARGET_MONO))) {     fprintf(stderr, "Error %d loading char '%c'\n", err, i); renderingOk=false;   }
        if ((err = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_MONO))) {      fprintf(stderr, "Error %d rendering char '%c'\n", err, i);     renderingOk=false;  }
        if ((err = FT_Get_Glyph(face->glyph, &glyph))) {      fprintf(stderr, "Error %d getting glyph '%c'\n", err, i);    renderingOk=false;    }

        if(!renderingOk)
        {
            listOfGlyphs.push_back(zeroGlyph);
            continue;
        }
        FT_Bitmap *bitmap = &face->glyph->bitmap;
        FT_BitmapGlyphRec *g= (FT_BitmapGlyphRec *)glyph;

        // Minimal font and per-glyph information is stored to
        // reduce flash space requirements.  Glyph bitmaps are
        // fully bit-packed; no per-scanline pad, though end of
        // each character may be padded to next byte boundary
        // when needed.  16-bit offset means 64K max for bitmaps,
        // code currently doesn't check for overflow.  (Doesn't
        // check that size & offsets are within bounds either for
        // that matter...please convert fonts responsibly.)
        bitPusher.align();
        int startOffset=bitPusher.offset();
        
        
        PFXglyph thisGlyph;
        thisGlyph.bitmapOffset = bitPusher.offset();
        thisGlyph.width = bitmap->width;
        thisGlyph.height = bitmap->rows;
        thisGlyph.xAdvance = face->glyph->advance.x >> 6;
        thisGlyph.xOffset = g->left;
        thisGlyph.yOffset = 1 - g->top;
        listOfGlyphs.push_back(thisGlyph);

        for (int y = 0; y < bitmap->rows; y++)
        {
          const uint8_t *line=bitmap->buffer+y * bitmap->pitch;
          for (int x = 0; x < bitmap->width; x++)
          {
            int byte = x / 8;
            int bit = 0x80 >> (x & 7);
            bitPusher.addBit(line[byte] & bit);
          }
        }
        if(compressed)
        {
            bitPusher.align();
            int size=bitPusher.offset()-startOffset;
            compressInPlace((uint8_t *)(bitPusher.data()+startOffset),size);
            bitPusher.setOffset(startOffset+size);
        }
    }
    face_height= face->size->metrics.height >> 6;
    FT_Done_Glyph(glyph);
    return true;
 }

// EOF